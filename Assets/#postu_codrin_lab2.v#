(* ----- Codrin Postu 3B3 , X - Lab 2 ----- *)

Inductive Nat := 
  | O : Nat 
  | S : Nat -> Nat.

Definition one := S O.
Definition two := S one.
Definition three := S two.
Definition four := S three.
Definition five := S four.

Fixpoint eq_Nat (n m : Nat) :=
match n, m with
| O, O       => true
| O, S _     => false
| S _, O     => false 
| S n', S m' => eq_Nat n' m'
end.

Compute eq_Nat O O.
Compute eq_Nat one O.
Compute eq_Nat one one.
Compute eq_Nat one four.
Compute eq_Nat five four.
Compute eq_Nat five five.

Fixpoint add (m n : Nat) : Nat :=
match m with
| O => n
| S m' => S (add m' n)
end.

Compute add one one.
Compute add one five.
Compute add five one.
Compute add five O.
Compute add O five.

Fixpoint max (m n : Nat) : Nat :=
match m with
| O => n
| S m' => match n with
          | O => m
          | S n' => S (max m' n')
          end
end.

Compute max one two.
Compute max O one.
Compute max one O.
Compute max four five.
Compute max five four.

(* -------------------------------------- *)
(* Practice *)

Lemma add_n_0_is_n : forall n, add n O = n.
Proof.
  induction n.
  simpl.
  reflexivity.
  simpl.
  rewrite IHn.
  reflexivity.
Qed.

Lemma plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity. Qed.

Lemma plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.
Proof.
  intros n m.
intros H.
rewrite <- H.
reflexivity.
Qed.

Lemma plus_id_exercise : forall n m o : nat,
  n = m -> m = o -> n + m = m + o.
Proof.
  intros n m o.
intros H.
intros H1.
rewrite H.
rewrite H1.
reflexivity.
Qed.

Check plus_id_exercise.

(* -------------------------------------- *)
(* 1. *)

Fixpoint le_Nat (m n : Nat) : bool :=
  match m, n with
  | O, O => true
  | O, S _ => true
  | S _, O => false
  | S m', S n' => le_Nat m' n'
  end.

Compute le_Nat O O. (* true *)
Compute le_Nat O one. (* true *)
Compute le_Nat one O. (* false *)
Compute le_Nat one one. (* true *)
Compute le_Nat one five. (* true *)
Compute le_Nat five one. (* false *)
Compute le_Nat five four. (* false *)
Compute le_Nat five five. (* true *)

(* 2. *)

Lemma le_then_O :
forall n : Nat,
 le_Nat n O = true ->
 n = O.
Proof.
 intros n. destruct n as [| n'] eqn:E. (*intro pattern *)
 Show 2.
 - simpl. intro H. reflexivity.
 - simpl. intro H. inversion H.
 Qed.

(* 3. *)

Lemma le_refl:
forall x,
 le_Nat x x = true.
Proof.
 induction x.
  simpl.
  reflexivity.
  simpl.
  rewrite IHx.
  reflexivity.
Qed.

Lemma le_Trans0 :
forall m n p,
  le_Nat m n = true ->
  le_Nat n p = true ->
  le_Nat m p = true.
Proof.
  induction m.
  - simpl. reflexivity.
  - intros n p H H'.
    simpl in H.
    destruct n.

Lemma le_Trans :
forall m n p,
 le_Nat m n = true ->
 le_Nat n p = true ->
 le_Nat m p = true.
Proof.
  (* facem direct inductie dupa m *)
  induction m; intros.
  - destruct H. 
    simpl. 
    destruct p. 
    destruct n.
    + reflexivity. 
    + reflexivity.
    + destruct n. 
      reflexivity. 
      reflexivity.
  - (* observ ca in IHm am in partea dreapta a implicatiei ceva despre m si p *)
    (* asa cum mi se cere in goal *)
    (* voi incerca sa obtin ceva despre partea stanga a implicatiei ca sa pot utiliza *)
    (* IHM intr-un modus ponens *)
    (* in H am informatii despre m si n - adica partea stanga a implicatiei *)
    simpl in H.
    + destruct n.
      ++ inversion H.
      ++ simpl.
         destruct p.
         ** simpl in H0.
            inversion H0.
         ** simpl in H0.
            apply IHm in H0.
            exact H0.
            exact H.
Qed.

Lemma le_Trans2 :
forall m n p,
 le_Nat m n = true ->
 le_Nat n p = true ->
 le_Nat m p = true.
Proof.
  intros.
  induction m.
  - destruct H. 
    simpl. 
    destruct p. 
    destruct n.
    + reflexivity. 
    + reflexivity.
    + destruct n. 
      reflexivity. 
      reflexivity.
  - simpl in H.
    destruct n.
    ++ inversion H.
    ++ simpl.
       destruct p.
       +++ simpl in H0.
           inversion H0.
       +++ simpl in H0.
           apply IHm in H0.
  (* blocat *)
Qed.
  

Lemma le_Trans :
forall m n p,
 le_Nat m n = true ->
 le_Nat n p = true ->
 le_Nat m p = true.
Proof.
  intros.
  induction m.
  -  induction p.
    + induction n.
      reflexivity.
      reflexivity.
    + rewrite <- IHp.
      simpl. destruct p. reflexivity. reflexivity.
      rewrite <- H0.
    
Qed.

Lemma le_Trans :
forall m n p,
 le_Nat m n = true ->
 le_Nat n p = true ->
 le_Nat m p = true.
Proof.
 induction m.
 Show 2.
  - induction n.
    Show 2.
    -- induction p. 
    simpl. 
    intro H. 
    reflexivity.
    simpl.
    intro H.
    reflexivity.
  --simpl.
    induction p.
Qed.


(* 4. *)

Lemma le_add :
forall x y,
 le_Nat x (add x y) = true.
Proof.
  induction x.
  -induction y.
  -- simpl. reflexivity.
  -- simpl. reflexivity.
  - simpl. intros y. rewrite IHx. reflexivity.
Qed.

(* 5 *)

Lemma le_add_consistent :
forall m n k,
 le_Nat m n = true ->
 le_Nat m (add n k) = true.
Proof.
  intros.
  rewrite <- H.
  


(* 6 *)

(*Lemma le_max_true :
forall m n,
 le_Nat m n = true ->
 max m n = n.
Proof.
 intros m n.
 intros H.
 induction m.
 - trivial.
 - induction m.
 -- simpl. destruct n. 
 --- inversion H.
 --- reflexivity.
 -- simpl. rewrite IHm0.
Qed.
*)